# 数组和切片和map

## 数组 array

1. 数组的定义
```go
var a [5]int        // 默认值都是 0
var b = [3]int{1, 2, 3}
c := [3]string{"a", "b", "c"}
```
> 数组长度是类型的一部分，一旦定义，就不能调整大小
> [5]int 和 [3]int 是 不同类型

1. 访问与修改
```go
a := [...]int{10, 20, 30}

fmt.Println(a[0]) // 10

a[1] = 99
fmt.Println(a) // [10 99 30]
```
> 使用 ... 自动推导数组长度

1. 遍历数组
```go
for i := 0; i < len(a); i++ {
    fmt.Println(a[i])
}

// 推荐方式
for index, value := range a {
    fmt.Println(index, value)
}
// 忽略索引
for _, value := range a {
    fmt.Println(value)
}
```

4. 多维数组
```go
var a [3][2]int
a[0][0] = 1
a[0][1] = 2
a[1][0] = 3
a[1][1] = 4
```

5. 数组是值类型

数组是值类型 Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映。

```go
func modify(arr [3]int) {
    arr[0] = 100
}

a := [3]int{1, 2, 3}
modify(a)

fmt.Println(a) // [1 2 3] 没变
```

## 切片 slice

切片是对数组的引用，长度可变，是 Go 中最常用的结构

1. 切片的定义
```go
// 方式一：直接声明
var s []int          // nil 切片
s = []int{1, 2, 3}

// 方式二：make
// make(type, len, cap)
s := make([]int, 0, 10)

// 方式三：基于数组
arr := [5]int{1, 2, 3, 4, 5}
s := arr[1:4] // [2 3 4]
```

2. len 和 cap
- len：当前长度
- cap：底层数组容量
```go
s := make([]int, 3, 10)
fmt.Println(len(s)) // 3
fmt.Println(cap(s)) // 10
```

3. append
```go
s := []int{1, 2, 3}
s = append(s, 4, 5, 6)
fmt.Println(s) // [1 2 3 4 5 6]
```
> 注意：append 可能触发扩容，返回新 slice
```go
s1 := []int{1, 2}
s2 := append(s1, 3)

fmt.Println(s1, s2) // [1 2] [1 2 3]
```

4. 切片是引用类型

```go
func modify(s []int) {
    s[0] = 100
}

s := []int{1, 2, 3}
modify(s)

fmt.Println(s) // [100 2 3]
```

5. 切片截取
```go
s := []int{1, 2, 3, 4, 5}

fmt.Println(s[1:3]) // [2 3]
fmt.Println(s[:2])  // [1 2]
fmt.Println(s[2:])  // [3 4 5]
```

6. nil切片 vs 空切片
```go
var a []int          // nil
b := []int{}         // 空切片
c := make([]int, 0)  // 空切片

fmt.Println(a == nil) // true
fmt.Println(b == nil) // false
```

- nil切片（未初始化）
  - a == nil 为 true
  - len(a) == 0
  - cap(a) == 0
  - 没有底层数组，不占用内容
- 空切片（已初始化，但没元素）
  - b == nil 为 false
  - len(b) == 0
  - cap(b) == 0（或 >0，取决于 make）
  - 有切片结构，可能有底层数组
  - 通常会分配内存（实现相关）

JSON 序列号的差异
```go
var a []int
b := []int{}
// nil 切片 为 null
// 空切片 为 []
```
> 接口返回时经常要求 `[]` 而不是 `null`

7. 删除 slice 中的某一项
```go
s := []int{1, 2, 3, 4, 5}
s = append(s[:2], s[3:]...)
fmt.Println(s) // [1 2 4 5]
```
8. 复制 slice
```go
// 第一种
s1 := []int{1, 2, 3}
s2 := make([]int, len(s1))
copy(s2, s1)
fmt.Println(s2) // [1 2 3]
// 第二种
s2 := s1[:]
fmt.Println(s2) // [1 2 3]
```

9. slice 的扩容机制

`append` 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 `...` 传入 slice，直接追加一个切片。

`append`函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。

使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 `len-1` 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。

这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 `slice` 的容量是留了一定的 `buffer` 的。否则，每次添加元素的时候，都会发生迁移，成本太高。

### 切片的原理图

![图片.png](04.%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E5%92%8Cmap.assets/1591789558464-5cd3aeed-1816-4617-ad5d-4960f1d71469.png)

> 思考：slice 是值传递还是引用传递？
>
> slice 是值传递

```go
s1 := []int{1, 2, 3}
s2 := s1
s2[1] = 99
fmt.Printf("s1=%v s2=%v\n", s1, s2) // s1=[1, 99, 3] s2=[1, 99, 3]
```

slice是值传递，但为什么改变s2中的值会更改到s1中的值？

s1 和 s2 的len和cap是相同的，它们会指向同一个地址，所以更改s2，会更改到s1的值

![image-20251230093104132](04.%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E5%92%8Cmap.assets/image-20251230093104132.png)

如果扩容了 s2，那么s1和s2就不会指向同一个地址了

```go
s1 := []int{1, 2, 3}
s2 := s1
s2 = append(s2, 4)
s2[1] = 99
fmt.Printf("s1=%v s2=%v\n", s1, s2) // s1=[1, 2, 3] s2=[1, 99, 3, 4]
```

![image-20251230093538518](04.%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E5%92%8Cmap.assets/image-20251230093538518.png)

当容量不够，slice会自动扩容，刚开始是成倍的，后面会变缓

```go
var data []int
for i := range 2000 {
    data = append(data, i)
    fmt.Printf("len: %d, cap: %d\r\n", len(data), cap(data))
}
```

```go
len: 1, cap: 1
len: 2, cap: 2
len: 3, cap: 4
...
len: 5, cap: 8
...
len: 8, cap: 16
...
len: 65, cap: 128
...
len: 129, cap: 256
...
len: 513, cap: 848
...
```

slice 的类型

```go
type slice struct {
	array unsafe.Pointer   // 用来存储实际数据的数组指针，指向一块连续的内存
	len   int              // 切片中元素的数量
	cap   int              // array数组的长度
}
```

## map (映射/字典)

map是一个key(索引)和value(值)的无序集合， 主要是查询方便

1. 定义
```go
var m map[string]int        // nil map，不能直接赋值
m = make(map[string]int)

m2 := map[string]int{
    "apple":  10,
    "banana": 5,
}
```
未初始化的 map 写入，会 panic
```go
var m map[string]int
m["a"] = 1 // panic
```

2. map的增删改查
```go
m := map[string]int {
    "a": 0,
}

// 增 / 改
m["a"] = 1
m["a"] = 2

// 查
v := m["a"]

// 判断 key 是否存在
v, ok := m["b"]
if !ok {
    fmt.Println("key 不存在")
}

// 删
delete(m, "a")
```

3. map的遍历
```go
for k, v := range m {
    fmt.Println(k, v)
}
```
> 注意：map 遍历是无序的，不能保证每次遍历的顺序相同

4. map 是引用类型
```go
func modify(m map[string]int) {
    m["x"] = 100
}

m := map[string]int{}
modify(m)

fmt.Println(m) // map[x:100]
```

5. map 的 value 是 slice
```go
m := make(map[string][]int)

m["a"] = append(m["a"], 1, 2, 3)
fmt.Println(m) // map[a:[1 2 3]]
```

### 对比

| 特性            | array | slice | map  |
| --------------- | ----- | ----- | ---- |
| 长度是否固定    | 是    | 否    | 否   |
| 是否引用类型    | 否    | 是    | 是   |
| 是否常用        | 否    | 是    | 是   |
| 是否支持 append | 否    | 是    | 否   |
| 是否有顺序      | 是    | 是    | 否   |

- 数组是值拷贝，切片是引用
- append 可能导致底层数组变化
- nil map 不能写
- map 遍历顺序不固定
- slice 的 cap 会影响性能

## 链表 list

两种定义方法：

- var name list.List
- list.New()

```go
func main() {
	// var mylist list.List
	mylist := list.New()

	//放在尾部
	mylist.PushBack("go")
	mylist.PushBack("grpc")
	mylist.PushBack("mysql")

	//头部放数据
	//遍历打印值, 正序
	i := mylist.Front()
	for ; i != nil; i = i.Next() {
		if i.Value.(string) == "grpc" {
			break
		}
	}
	mylist.Remove(i)

	for i := mylist.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}
}
```

![image-20251230100015261](04.%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87%E5%92%8Cmap.assets/image-20251230100015261.png)

可以更快捷得插入和删除数据