# 运算符与流程控制

## 运算符

### 算术运算符

| 运算符 | 描述 |
| ---- | ---- |
| +    | 加法 |
| -    | 减法 |
| *    | 乘法 |
| /    | 除法 |
| %    | 取余 |

```go
a := 10
b := 3

fmt.Println(a + b) // 13
fmt.Println(a - b) // 7
fmt.Println(a * b) // 30
fmt.Println(a / b) // 3  整数除法
fmt.Println(a % b) // 1
```
> 整数相除结果仍是整数
> 没有 ++a，只有 a++，且不能写在表达式中

### 关系运算符

| 运算符 | 描述 |
| ---- | ---- |
| ==    | 等于 |
| !=    | 不等于 |
| >    | 大于 |
| <    | 小于 |
| >=    | 大于等于 |
| <=    | 小于等于 |

```go
fmt.Println(5 > 3)   // true
fmt.Println(5 == 5) // true
```

### 逻辑运算符

| 运算符 | 描述 |
| ---- | ---- |
| &&    | 与 |
| ||    | 或 |
| !    | 非 |

```go
age := 20
fmt.Println(age > 18 && age < 30) // true
fmt.Println(!(age > 18))          // false
```

### 赋值运算符

| 运算符 | 描述 |
| ---- | ---- |
| =    | 赋值 |
| +=    | 加等于 |
| -=    | 减等于 |
| *=    | 乘等于 |
| /=    | 除等于 |
| %=    | 取余等于 |

```go
a := 10
a += 5 // a = a + 5
a -= 2
a *= 3
a /= 2
a %= 3
fmt.Println(a) // 15
```

## 流程控制

### if else

```go
if score >= 90 {
    fmt.Println("优秀")
} else if score >= 60 {
    fmt.Println("及格")
} else {
    fmt.Println("不及格")
}
```

if 的特殊写法
```go
if num := 10; num > 5 {
    fmt.Println(num)
}
// num 只在 if 内部有效
```
特点：
- 条件不需要括号()
- {} 必须写
- 不能写成一行：if () {}

### for

基本用法：
```go
for i := 0; i < 5; i++ {
    fmt.Println(i)
}
```
类似while的用法
```go
i := 0
for i < 5 {
    fmt.Println(i)
    i++
}
```
无限循环
```go
for {
    fmt.Println("loop")
}
```
for range 遍历
```go
arr := []int{10, 20, 30}

for index, value := range arr {
    fmt.Println(index, value)
}
// 只需要值
for _, value := range arr {
    fmt.Println(value)
}
```
break
```go
for i := 0; i < 5; i++ {
    if i == 3 {
        break
    }
    fmt.Println(i)
}
```
continue
```go
for i := 0; i < 5; i++ {
    if i == 3 {
        continue
    }
    fmt.Println(i)
}
```
goto: 可以跳转到指定标签
```go
label:
    fmt.Println("label")
goto label
```
比如使用 goto 退出多层循环
```go
// 优化前
func main() {
    var breakAgain bool
    // 外循环
    for x := 0; x < 10; x++ {
        // 内循环
        for y := 0; y < 10; y++ {
            // 满足某个条件时, 退出循环
            if y == 2 {
                // 设置退出标记
                breakAgain = true
                // 退出本次循环
                break
            }
        }
        // 根据标记, 还需要退出一次循环
        if breakAgain {
            break
        }
    }
    fmt.Println("done")
}
// 优化后
func main() {
    for x := 0; x < 10; x++ {
        for y := 0; y < 10; y++ {
            if y == 2 {
                // 跳转到标签
                goto breakHere
            }
        }
    }
    // 手动返回, 避免执行进入标签
    return
    // 标签
    breakHere:
        fmt.Println("done")
}
```
使用goto集中处理错误
```go
// 优化前
err := firstCheckError()
if err != nil {
    fmt.Println(err)
    exitProcess()
    return
}
err = secondCheckError()
if err != nil {
    fmt.Println(err)
    exitProcess()
    return
}
fmt.Println("done")
// 优化后
err := firstCheckError()
if err != nil {
    goto onExit
}
err = secondCheckError()
if err != nil {
    goto onExit
}
fmt.Println("done")
return
onExit:
    fmt.Println(err)
    exitProcess()
```

### switch

基本用法
```go
day := 3

switch day {
case 1:
    fmt.Println("星期一")
case 2:
    fmt.Println("星期二")
case 3:
    fmt.Println("星期三")
default:
    fmt.Println("未知")
}
```
> Go 的 switch 默认自带 break

一个 case 多个值
```go
switch day {
case 1, 2, 3, 4, 5:
    fmt.Println("工作日")
case 6, 7:
    fmt.Println("周末")
}
```
switch 可以没有表达式（类似 if）
```go
score := 85

switch {
case score >= 90:
    fmt.Println("优秀")
case score >= 60:
    fmt.Println("及格")
default:
    fmt.Println("不及格")
}
```
fallthrough 穿透
```go
switch num := 1; num {
case 1:
    fmt.Println("one")
    fallthrough
case 2:
    fmt.Println("two")
}
```
> fallthrough 会穿透到下一个 case，即使条件不满足

type switch
switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。
```go
func main() {
   var x interface{}
     
   switch i := x.(type) {
      case nil:
         fmt.Printf(" x 的类型 :%T",i)
      case int:
         fmt.Printf("x 是 int 型")
      case float64:
         fmt.Printf("x 是 float64 型")
      case func(int) float64:
         fmt.Printf("x 是 func(int) 型")
      case bool, string:
         fmt.Printf("x 是 bool 或 string 型" )
      default:
         fmt.Printf("未知型")
   } 
}
```
